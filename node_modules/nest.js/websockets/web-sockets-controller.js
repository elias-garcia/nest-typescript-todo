"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const invalid_socket_port_exception_1 = require("./exceptions/invalid-socket-port.exception");
const gateway_metadata_explorer_1 = require("./gateway-metadata-explorer");
const constants_1 = require("./constants");
const metadata_scanner_1 = require("../core/metadata-scanner");
const middlewares_injector_1 = require("./middlewares-injector");
class WebSocketsController {
    constructor(socketServerProvider, container) {
        this.socketServerProvider = socketServerProvider;
        this.metadataExplorer = new gateway_metadata_explorer_1.GatewayMetadataExplorer(new metadata_scanner_1.MetadataScanner());
        this.middlewaresInjector = new middlewares_injector_1.MiddlewaresInjector(container);
    }
    hookGatewayIntoServer(instance, metatype, module) {
        const namespace = Reflect.getMetadata(constants_1.NAMESPACE_METADATA, metatype) || '';
        const port = Reflect.getMetadata(constants_1.PORT_METADATA, metatype) || 80;
        if (!Number.isInteger(port)) {
            throw new invalid_socket_port_exception_1.InvalidSocketPortException(port, metatype);
        }
        this.subscribeObservableServer(instance, namespace, port, module);
    }
    subscribeObservableServer(instance, namespace, port, module) {
        const messageHandlers = this.metadataExplorer.explore(instance);
        const observableServer = this.socketServerProvider.scanForSocketServer(namespace, port);
        this.injectMiddlewares(observableServer, instance, module);
        this.hookServerToProperties(instance, observableServer.server);
        this.subscribeEvents(instance, messageHandlers, observableServer);
    }
    injectMiddlewares({ server }, instance, module) {
        this.middlewaresInjector.inject(server, instance, module);
    }
    subscribeEvents(instance, messageHandlers, observableServer) {
        const { init, disconnect, connection, server } = observableServer;
        this.subscribeInitEvent(instance, init);
        init.next(server);
        const handler = this.getConnectionHandler(this, instance, messageHandlers, disconnect, connection);
        server.on(constants_1.CONNECTION_EVENT, handler);
    }
    getConnectionHandler(context, instance, messageHandlers, disconnect, connection) {
        return (client) => {
            context.subscribeConnectionEvent(instance, connection);
            connection.next(client);
            context.subscribeMessages(messageHandlers, client, instance);
            context.subscribeDisconnectEvent(instance, disconnect);
            client.on(constants_1.DISCONNECT_EVENT, socket => disconnect.next(socket));
        };
    }
    subscribeInitEvent(instance, event) {
        if (instance.afterInit) {
            event.subscribe(instance.afterInit.bind(instance));
        }
    }
    subscribeConnectionEvent(instance, event) {
        if (instance.handleConnection) {
            event.subscribe(instance.handleConnection.bind(instance));
        }
    }
    subscribeDisconnectEvent(instance, event) {
        if (instance.handleDisconnect) {
            event.subscribe(instance.handleDisconnect.bind(instance));
        }
    }
    subscribeMessages(messageHandlers, client, instance) {
        messageHandlers.map(({ message, targetCallback }) => {
            client.on(message, targetCallback.bind(instance, client));
        });
    }
    hookServerToProperties(instance, server) {
        for (const propertyKey of this.metadataExplorer.scanForServerHooks(instance)) {
            Reflect.set(instance, propertyKey, server);
        }
    }
}
exports.WebSocketsController = WebSocketsController;

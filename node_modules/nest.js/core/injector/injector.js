"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const unknown_dependencies_exception_1 = require("../../errors/exceptions/unknown-dependencies.exception");
const runtime_exception_1 = require("../../errors/exceptions/runtime.exception");
const shared_utils_1 = require("../../common/utils/shared.utils");
const constants_1 = require("../../common/constants");
class Injector {
    loadInstanceOfMiddleware(wrapper, collection, module) {
        const { metatype } = wrapper;
        const currentMetatype = collection.get(metatype.name);
        if (currentMetatype.instance !== null)
            return;
        this.resolveConstructorParams(wrapper, module, null, argsInstances => {
            collection.set(metatype.name, {
                instance: new metatype(...argsInstances),
                metatype,
            });
        });
    }
    loadInstanceOfRoute(wrapper, module) {
        const routes = module.routes;
        this.loadInstance(wrapper, routes, module);
    }
    loadPrototypeOfInstance({ metatype, name }, collection) {
        if (!collection)
            return;
        const target = collection.get(name);
        if (target.isResolved || !shared_utils_1.isNil(target.inject))
            return;
        collection.set(name, Object.assign({}, collection.get(name), { instance: Object.create(metatype.prototype) }));
    }
    loadInstanceOfComponent(wrapper, module) {
        const components = module.components;
        this.loadInstance(wrapper, components, module);
    }
    loadInstance(wrapper, collection, module) {
        const { metatype, name, inject } = wrapper;
        const currentMetatype = collection.get(name);
        if (shared_utils_1.isUndefined(currentMetatype)) {
            throw new runtime_exception_1.RuntimeException('');
        }
        if (currentMetatype.isResolved)
            return;
        this.resolveConstructorParams(wrapper, module, inject, argsInstances => {
            if (shared_utils_1.isNil(inject)) {
                currentMetatype.instance = Object.assign(currentMetatype.instance, new metatype(...argsInstances));
            }
            else {
                currentMetatype.instance = currentMetatype.metatype(...argsInstances);
            }
            currentMetatype.isResolved = true;
        });
    }
    resolveConstructorParams(wrapper, module, inject, callback) {
        const args = shared_utils_1.isNil(inject) ? this.reflectConstructorParams(wrapper.metatype) : inject;
        const instances = args.map(param => this.resolveSingleParam(wrapper, param, module));
        callback(instances);
    }
    reflectConstructorParams(type) {
        const paramtypes = Reflect.getMetadata(constants_1.PARAMTYPES_METADATA, type) || [];
        const selfParams = this.reflectSelfParams(type);
        selfParams.forEach(({ index, param }) => paramtypes[index] = param);
        return paramtypes;
    }
    reflectSelfParams(type) {
        return Reflect.getMetadata(constants_1.SELF_DECLARED_DEPS_METADATA, type) || [];
    }
    resolveSingleParam(wrapper, param, module) {
        if (shared_utils_1.isUndefined(param)) {
            throw new runtime_exception_1.RuntimeException();
        }
        return this.resolveComponentInstance(module, shared_utils_1.isFunction(param) ? param.name : param, wrapper);
    }
    resolveComponentInstance(module, name, wrapper) {
        const components = module.components;
        const instanceWrapper = this.scanForComponent(components, name, module, wrapper);
        if (!instanceWrapper.isResolved) {
            this.loadInstanceOfComponent(components.get(name), module);
        }
        return instanceWrapper.instance;
    }
    scanForComponent(components, name, module, { metatype }) {
        if (components.has(name)) {
            return components.get(name);
        }
        const instanceWrapper = this.scanForComponentInRelatedModules(module, name);
        if (shared_utils_1.isNil(instanceWrapper)) {
            throw new unknown_dependencies_exception_1.UnknownDependenciesException(metatype.name);
        }
        return instanceWrapper;
    }
    scanForComponentInRelatedModules(module, name) {
        const relatedModules = module.relatedModules || [];
        let component = null;
        relatedModules.forEach((relatedModule) => {
            const { components, exports } = relatedModule;
            if (!exports.has(name) || !components.has(name))
                return;
            component = components.get(name);
            if (!component.isResolved) {
                this.loadInstanceOfComponent(component, relatedModule);
            }
        });
        return component;
    }
}
exports.Injector = Injector;

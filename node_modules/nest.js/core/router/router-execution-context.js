"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const constants_1 = require("../../common/constants");
const shared_utils_1 = require("../../common/utils/shared.utils");
class RouterExecutionContext {
    constructor(paramsFactory) {
        this.paramsFactory = paramsFactory;
    }
    create(instance, callback) {
        const metadata = this.reflectCallbackMetadata(instance, callback);
        if (shared_utils_1.isUndefined(metadata)) {
            return callback.bind(instance);
        }
        const keys = Object.keys(metadata);
        const argsLength = this.getArgumentsLength(keys, metadata);
        const args = this.createNullArray(argsLength);
        return (req, res, next) => {
            const indexValuePairs = this.exchangeKeysForValues(keys, metadata, { req, res, next });
            indexValuePairs.forEach(pair => args[pair.index] = pair.value);
            return callback.apply(instance, args);
        };
    }
    mapParamType(key) {
        const keyPair = key.split(':');
        return Number(keyPair[0]);
    }
    reflectCallbackMetadata(instance, callback) {
        return Reflect.getMetadata(constants_1.ROUTE_ARGS_METADATA, instance, callback.name);
    }
    getArgumentsLength(keys, metadata) {
        return Math.max(...keys.map(key => metadata[key].index)) + 1;
    }
    createNullArray(length) {
        return Array.apply(null, { length }).fill(null);
    }
    exchangeKeysForValues(keys, metadata, { req, res, next }) {
        return keys.map(key => ({
            index: metadata[key].index,
            value: this.paramsFactory.exchangeKeyForValue(this.mapParamType(key), metadata[key].data, { req, res, next }),
        }));
    }
}
exports.RouterExecutionContext = RouterExecutionContext;

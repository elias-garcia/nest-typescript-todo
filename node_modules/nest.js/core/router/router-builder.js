"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("reflect-metadata");
const unkown_request_mapping_exception_1 = require("../../errors/exceptions/unkown-request-mapping.exception");
const shared_utils_1 = require("../../common/utils/shared.utils");
const router_method_factory_1 = require("../helpers/router-method-factory");
const constants_1 = require("../../common/constants");
const logger_service_1 = require("../../common/services/logger.service");
const messages_1 = require("../helpers/messages");
class RouterBuilder {
    constructor(routerProxy, expressAdapter) {
        this.routerProxy = routerProxy;
        this.expressAdapter = expressAdapter;
        this.routerMethodFactory = new router_method_factory_1.RouterMethodFactory();
        this.logger = new logger_service_1.Logger(RouterBuilder.name);
    }
    build(instance, metatype) {
        const router = this.expressAdapter.createRouter();
        const path = this.fetchRouterPath(metatype);
        const routerPaths = this.scanForPaths(instance);
        this.applyPathsToRouterProxy(router, routerPaths);
        return { path, router };
    }
    scanForPaths(instance) {
        const instancePrototype = Object.getPrototypeOf(instance);
        return this.scanForPathsFromPrototype(instance, instancePrototype);
    }
    scanForPathsFromPrototype(instance, instancePrototype) {
        return Object.getOwnPropertyNames(instancePrototype)
            .filter((method) => {
            const descriptor = Object.getOwnPropertyDescriptor(instancePrototype, method);
            if (descriptor.set || descriptor.get) {
                return false;
            }
            return !shared_utils_1.isConstructor(method) && shared_utils_1.isFunction(instancePrototype[method]);
        })
            .map((methodName) => this.exploreMethodMetadata(instance, instancePrototype, methodName))
            .filter((path) => path !== null);
    }
    exploreMethodMetadata(instance, instancePrototype, methodName) {
        const callbackMethod = instancePrototype[methodName];
        const routePath = Reflect.getMetadata(constants_1.PATH_METADATA, callbackMethod);
        if (shared_utils_1.isUndefined(routePath)) {
            return null;
        }
        const requestMethod = Reflect.getMetadata(constants_1.METHOD_METADATA, callbackMethod);
        return {
            targetCallback: callbackMethod.bind(instance),
            path: this.validateRoutePath(routePath),
            requestMethod,
        };
    }
    applyPathsToRouterProxy(router, routePaths) {
        (routePaths || []).map((pathProperties) => {
            this.bindMethodToRouterProxy(router, pathProperties);
        });
    }
    bindMethodToRouterProxy(router, pathProperties) {
        const { path, requestMethod, targetCallback } = pathProperties;
        const routerMethod = this.routerMethodFactory.get(router, requestMethod).bind(router);
        const proxy = this.routerProxy.createProxy(targetCallback);
        routerMethod(path, proxy);
        this.logger.log(messages_1.getRouteMappedMessage(path, requestMethod));
    }
    fetchRouterPath(metatype) {
        const path = Reflect.getMetadata(constants_1.PATH_METADATA, metatype);
        return this.validateRoutePath(path);
    }
    validateRoutePath(path) {
        if (shared_utils_1.isUndefined(path)) {
            throw new unkown_request_mapping_exception_1.UnkownRequestMappingException();
        }
        return shared_utils_1.validatePath(path);
    }
}
exports.RouterBuilder = RouterBuilder;

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const sinon = require("sinon");
const chai_1 = require("chai");
const server_tcp_1 = require("../../server/server-tcp");
const constants_1 = require("../../constants");
describe('ServerTCP', () => {
    let server;
    beforeEach(() => {
        server = new server_tcp_1.ServerTCP({});
    });
    describe('bindHandler', () => {
        let getSocketInstance;
        const socket = { on: sinon.spy() };
        beforeEach(() => {
            getSocketInstance = sinon.stub(server, 'getSocketInstance').callsFake(() => socket);
        });
        it('should bind message event to handler', () => {
            server.bindHandler(null);
            chai_1.expect(socket.on.called).to.be.true;
        });
    });
    describe('listen', () => {
        const serverMock = { listen: sinon.spy() };
        beforeEach(() => {
            server.server = serverMock;
        });
        it('should call native listen method with expected arguments', () => {
            const callback = () => { };
            server.listen(callback);
            chai_1.expect(serverMock.listen.calledWith(server.port, callback)).to.be.true;
        });
    });
    describe('handleMessage', () => {
        let socket;
        const msg = {
            pattern: 'test',
            data: 'tests',
        };
        beforeEach(() => {
            socket = {
                sendMessage: sinon.spy()
            };
        });
        it('should send NO_PATTERN_MESSAGE error if key is not exists in handlers object', () => {
            server.handleMessage(socket, msg);
            chai_1.expect(socket.sendMessage.calledWith({ err: constants_1.NO_PATTERN_MESSAGE })).to.be.true;
        });
        it('should call handler if exists in handlers object', () => {
            const handler = sinon.spy();
            server.msgHandlers = {
                [JSON.stringify(msg.pattern)]: handler
            };
            server.handleMessage(socket, msg);
            chai_1.expect(handler.calledOnce).to.be.true;
        });
    });
    describe('getMessageHandler', () => {
        let handler;
        const sendMessage = sinon.spy();
        const socket = { sendMessage };
        beforeEach(() => {
            handler = server.getMessageHandler(socket);
        });
        it(`should return function`, () => {
            chai_1.expect(typeof server.getMessageHandler(null)).to.be.eql('function');
        });
        it(`should change order when second parameter is undefined or null`, () => {
            const response = 'test';
            handler(response);
            chai_1.expect(sendMessage.calledWith({ err: null, response })).to.be.true;
        });
        it(`should call "sendMessage" with expected message object`, () => {
            const err = 'err';
            const response = 'test';
            handler(err, response);
            chai_1.expect(sendMessage.calledWith({ err, response })).to.be.true;
        });
    });
});
